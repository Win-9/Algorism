# 문제

지민이는 N개의 원소를 포함하고 있는 양방향 순환 큐를 가지고 있다. 지민이는 이 큐에서 몇 개의 원소를 뽑아내려고 한다.

지민이는 이 큐에서 다음과 같은 3가지 연산을 수행할 수 있다.

첫 번째 원소를 뽑아낸다. 이 연산을 수행하면, 원래 큐의 원소가 a1, ..., ak이었던 것이 a2, ..., ak와 같이 된다.
왼쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, ..., ak가 a2, ..., ak, a1이 된다.
오른쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, ..., ak가 ak, a1, ..., ak-1이 된다.
큐에 처음에 포함되어 있던 수 N이 주어진다. 그리고 지민이가 뽑아내려고 하는 원소의 위치가 주어진다. (이 위치는 가장 처음 큐에서의 위치이다.) 이때, 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 프로그램을 작성하시오.


https://www.acmicpc.net/problem/1021

# 전략

우선 앞뒤로 넣어야 한다는 점에서 덱 자료구조를 사용하려고 했는데 내가 사용하려는 방식은 index를 조회를 해야하는데
큐를 베이스로 만들어진 덱은 인덱스 조회가 불가능 하기 때문에
> 메소드를 만들어 가능하지만 코드가 길어지며, 불필요한 소요가 많이 든다.

따라서 list를 이용하여 queue처럼 사용하였다.

pop을 하려는 요소를 arr에 저장 시키고, 저장하려는 값들은 list에 저장시켰다.
while문을 통하여 arr 첫번째 요소가 list에서 어느 인덱스에 존재하는지 조회시키고 인덱스가 size보다 작으면 1번, 아니면 2번을 하도록 하고
get을 했을시 일치하면 remove하고록 한다.

```java
if(queue.indexOf(arr[idx])<=queue.size()/2) {
    			queue.add(queue.remove(0));
    			count++;
    			print(queue);

    		}
    		
    		else {
    			queue.add(0,queue.remove(queue.size()-1));
    			count++;
    			print(queue);

    		}
```



---

C++로 단 5줄만에 끝난사람도 있던데... 와우...
