### 문제
1번부터 N번까지의 지점이 있다. 각각의 지점들은 차례로, 그리고 원형으로 연결되어 있다.   
이 지점들 중 두 곳에 두 개의 탑을 세우려고 하는데, 두 탑의 거리가 최대가 되도록 만들려고 한다.   

지점들이 원형으로 연결되어 있기 때문에, 두 지점 사이에는 시계방향과 반시계방향의 두 경로가 존재한다.   
두 지점 사이의 거리를 잴 때에는, 이러한 값들 중에서 더 작은 값을 거리로 한다.   

연결되어 있는 두 지점 사이의 거리가 주어졌을 때, 두 탑의 거리의 최댓값을 계산하는 프로그램을 작성하시오.   
 
입력   
첫째 줄에 지점의 개수 N(2 ≤ N ≤ 50,000)이 주어진다. 다음 N개의 줄에는 차례로 두 지점 사이의 거리가 양의 정수로 주어진다.   
전체 거리의 총 합은 1,000,000,000을 넘지 않는다.   

출력   
첫째 줄에 답을 출력한다.   


### 풀이

그리디로 모든 경우를 탐색할 수 있지만 그럴경우 시간초과가 발생한다.   

시계와 반시계의 관계를 잘 이용해야 하는데 반시계거리와 시계 거리의 합은 항상 같고, 시계와 반시계의 관계는 서로 반대가 되는 관계이다.   
즉, 시계거리가 증가하면 반시계거리가 감소하고, 반시계거리가 증가하면 시계거리가 감소한다.   

그리고 또 알아햐 할 점은 시계와 반시계의 방향이 바뀌는 지점의 바로 전이 한 곳의 탑이 정해졌을때 다른 한쪽의 탑의 지점이다.

|두 점|시계|반시계|
|:--|:--|:--|
|a-b|1|14|
|a-c|3|12|
|a-d|6|9|
|a-e|10|5|

둘중 더 작은 값이 거리로 정해지는데, a-d의 거리가 6이므로 현재까지 제일 먼 거리이고, a-e거리가 5로 바뀌는 순간 최댓값이 깨진다.   
바로 이 지점이 제일 먼 거리의 지점이다.


따라서 이 둘중에서 더 작은 값이 정해지는 거리가 되고, 이 정해지는 거리들중 큰 값을 구하도록 한다.   

```java
while(end < N - 1 && start <= end) {
			int min = Math.min(current, sum - current);
			result = Math.max(min, result);
			
			if (min == current) {
				current += arr[++end];
				continue;
			}
			current -= arr[start++];
		}
```
더 작은 거리인 min을 구하고나서, 현재 거리가 min이라면 (방향이 변하지 않았다.) 계속 한쪽 방향의 길이를 쭉 늘려준다.   
하지만 현재 거리가 min이 아니라면 (방향이 변해야 한다.) 처음 정해진 지점의 위치를 옮겨서 탐색을 계속 하도록 한다.  

난 왜 인덱스를 건드려서 조작하는문제는 왜 뇌절이 오는지....
