### 문제

트리에서 리프 노드란, 자식의 개수가 0인 노드를 말한다.   

트리가 주어졌을 때, 노드 하나를 지울 것이다. 그 때, 남은 트리에서 리프 노드의 개수를 구하는 프로그램을 작성하시오.     
노드를 지우면 그 노드와 노드의 모든 자손이 트리에서 제거된다.   

예를 들어, 다음과 같은 트리가 있다고 하자.    

![image](https://user-images.githubusercontent.com/80390524/179468666-2c1f2009-b581-4015-847c-e29750789979.png)   


현재 리프 노드의 개수는 3개이다. (초록색 색칠된 노드) 이때, 1번을 지우면, 다음과 같이 변한다. 검정색으로 색칠된 노드가 트리에서 제거된 노드이다.   
![image](https://user-images.githubusercontent.com/80390524/179468698-dbdf4535-bd2c-4577-a3e9-d39def14d1d1.png)   



이제 리프 노드의 개수는 1개이다.   

입력
첫째 줄에 트리의 노드의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 0번 노드부터 N-1번 노드까지, 각 노드의 부모가 주어진다.   
만약 부모가 없다면 (루트) -1이 주어진다. 셋째 줄에는 지울 노드의 번호가 주어진다.   

출력
첫째 줄에 입력으로 주어진 트리에서 입력으로 주어진 노드를 지웠을 때, 리프 노드의 개수를 출력한다.   


### 풀이

dfs를 통한 그래프 탐색을 하는 문제이다.   
단, 연쇄적으로 탐색을 제외시킬 노드를 걸러야하는 제약이 있었다.   
처음에 삭제, 탐색의 각각의 메소드를 두어서 dfs를 두번진행시킬 생각이었지만, 시간이 너무 오래걸리기때문에 다른 방법을 생각하였다.   
제외시킬 노드를 만나면 Queue에 넣지 않고 다음 노드로 건너뛰면 연쇄적으로 탐색을 거를 수 있으므로 이 방법을 사용하였다.   
```java
while(!queue.isEmpty()) {
			int m = queue.poll();
			int count = 0;

			for(Integer node: list[m]) {
				if(node != except) {
					queue.add(node);
					count++;
				}
			}
			
			if(count == 0) {
				result++;
			}
		}
 ```


그러나 Iterator를 제대로 숙지 못하여서 테스트케이스마다 오류가 생기는게 문제였다.   
몇시간을 해멘 결과는 iterator는 다음 인자가 없어도 무조건 한번은 돈다는것... 꼭 주의하자.   
로직자체는 크게 어려움이 없는 문제였다.
