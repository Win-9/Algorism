# 문제

재환이가 1×N 크기의 미로에 갇혀있다. 미로는 1×1 크기의 칸으로 이루어져 있고, 각 칸에는 정수가 하나 쓰여 있다. 
i번째 칸에 쓰여 있는 수를 Ai라고 했을 때, 재환이는 Ai이하만큼 오른쪽으로 떨어진 칸으로 한 번에 점프할 수 있다.
예를 들어, 3번째 칸에 쓰여 있는 수가 3이면, 재환이는 4, 5, 6번 칸 중 하나로 점프할 수 있다.

재환이는 지금 미로의 가장 왼쪽 끝에 있고, 가장 오른쪽 끝으로 가려고 한다. 이때, 최소 몇 번 점프를 해야 갈 수 있는지 구하는 프로그램을 작성하시오.
만약, 가장 오른쪽 끝으로 갈 수 없는 경우에는 -1을 출력한다.

입력
첫째 줄에 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 Ai (0 ≤ Ai ≤ 100)가 주어진다.

출력
재환이가 최소 몇 번 점프를 해야 가장 오른쪽 끝 칸으로 갈 수 있는지 출력한다. 만약, 가장 오른쪽 끝으로 갈 수 없는 경우에는 -1을 출력한다.


# 풀이

dfs로도 구현이 가능하지만, dp를 이용하여 풀이를 하였다.   
각 위치에서 최소한으로 이동하는 경우를 dp라고 한다.   
모든 dp를 우선 무한대 값으로 둔다.   
가장 왼쪽의 자리는 자원을 소비하지 않으므로 0이다.   

이동을 할때마다 값을 갱신 시켜주어야 하는데 현재 이동가능한 범위를 num으로 추출을 하고, 현재의 dp + 1 과 존재하는dp의 값을 비교하여 더 작은 값으로 치환을 한다.   
```java
for (int i = 1; i <= N; i++) {

			if (dp[i] == Integer.MAX_VALUE)
				continue;

			int num = arr[i];

			for (int j = 1; j <= num; j++) {

				if (j + i > N)
					continue;

				dp[i + j] = Math.min(dp[i] + 1, dp[i + j]);
			}
		}
```
