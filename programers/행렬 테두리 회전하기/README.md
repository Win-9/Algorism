### 문제

rows x columns 크기인 행렬이 있습니다. 행렬에는 1부터 rows x columns까지의 숫자가 한 줄씩 순서대로 적혀있습니다.    

이 행렬에서 직사각형 모양의 범위를 여러 번 선택해, 테두리 부분에 있는 숫자들을 시계방향으로 회전시키려 합니다.    

각 회전은 (x1, y1, x2, y2)인 정수 4개로 표현하며, 그 의미는 다음과 같습니다.   

x1 행 y1 열부터 x2 행 y2 열까지의 영역에 해당하는 직사각형에서 테두리에 있는 숫자들을 한 칸씩 시계방향으로 회전합니다.   
다음은 6 x 6 크기 행렬의 예시입니다.   


![image](https://github.com/Win-9/Algorism/assets/80390524/136a7e63-f8e0-4497-915d-3254d76d48a5)   

이 행렬에 (2, 2, 5, 4) 회전을 적용하면, 아래 그림과 같이 2행 2열부터 5행 4열까지 영역의 테두리가 시계방향으로 회전합니다.    

이때, 중앙의 15와 21이 있는 영역은 회전하지 않는 것을 주의하세요.   


![image](https://github.com/Win-9/Algorism/assets/80390524/06793f54-236f-4ad8-afb7-52343b57dc43)    

행렬의 세로 길이(행 개수) rows, 가로 길이(열 개수) columns, 그리고 회전들의 목록 queries가 주어질 때, 각 회전들을 배열에 적용한 뒤,    

그 회전에 의해 위치가 바뀐 숫자들 중 가장 작은 숫자들을 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.   



### 풀이

특별히 구현해야 하는 알고리즘은 없었다.   
그러나 너무 빡쎈 구현이 기다린...   

시계방향으로 위, 오른쪽, 아래, 왼쪽 으로 돌리면 첫번째 있는 수는 변하기 어렵다.   
위쪽방향을 오른쪽 한칸 밀고, 오른쪽 방향을 아래도 한칸 민다고 하면 오른쪽 방향의 첫번째 수는 위쪽 방향의 변화되기 전 마지막 값을 가져야 하지만, 그러지 못한다.   
따라서 우리는 보정값을 저장하고 있다가 이를 대입시켜주어야 한다.   
이 보정값은 4방향 모두 존재하기 때문에 모두 넣어 주어야 한다.   

그러나 수정 순서 위, 왼, 아래, 오 순서로 변경하면 보정값 두번만 수정하면 된다.   
좌표를 회전시키면서 동시에 최솟값도 같이 구하도록 한다.   

보정값을 넣는 것을 잘못해서 디버깅만 몇시간이 걸렸다.   
이러한 빡구현 문제는 힘들다...









