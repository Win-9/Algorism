### 문제
길이가 같은 두 개의 큐가 주어집니다.    
하나의 큐를 골라 원소를 추출(pop)하고, 추출된 원소를 다른 큐에 집어넣는(insert) 작업을 통해 각 큐의 원소 합이 같도록 만들려고 합니다.    
이때 필요한 작업의 최소 횟수를 구하고자 합니다. 한 번의 pop과 한 번의 insert를 합쳐서 작업을 1회 수행한 것으로 간주합니다.  

큐는 먼저 집어넣은 원소가 먼저 나오는 구조입니다. 이 문제에서는 큐를 배열로 표현하며, 원소가 배열 앞쪽에 있을수록 먼저 집어넣은 원소임을 의미합니다.    
즉, pop을 하면 배열의 첫 번째 원소가 추출되며, insert를 하면 배열의 끝에 원소가 추가됩니다.   
예를 들어 큐 1, 2, 3, 4가 주어졌을 때, pop을 하면 맨 앞에 있는 원소 1이 추출되어 [2, 3, 4]가 되며, 이어서 5를 insert하면 [2, 3, 4, 5]가 됩니다.  

다음은 두 큐를 나타내는 예시입니다.

queue1 = [3, 2, 7, 2]   
queue2 = [4, 6, 5, 1]   
두 큐에 담긴 모든 원소의 합은 30입니다.    
따라서, 각 큐의 합을 15로 만들어야 합니다. 예를 들어, 다음과 같이 2가지 방법이 있습니다.

queue2의 4, 6, 5를 순서대로 추출하여 queue1에 추가한 뒤, queue1의 3, 2, 7, 2를 순서대로 추출하여 queue2에 추가합니다.    
그 결과 queue1은 [4, 6, 5], queue2는 [1, 3, 2, 7, 2]가 되며, 각 큐의 원소 합은 15로 같습니다. 이 방법은 작업을 7번 수행합니다.    
queue1에서 3을 추출하여 queue2에 추가합니다. 그리고 queue2에서 4를 추출하여 queue1에 추가합니다.    
그 결과 queue1은 [2, 7, 2, 4], queue2는 [6, 5, 1, 3]가 되며, 각 큐의 원소 합은 15로 같습니다. 이 방법은 작업을 2번만 수행하며, 이보다 적은 횟수로 목표를 달성할 수 없습니다.   
따라서 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수는 2입니다.   

길이가 같은 두 개의 큐를 나타내는 정수 배열 queue1, queue2가 매개변수로 주어집니다.    
각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수를 return 하도록 solution 함수를 완성해주세요.    
단, 어떤 방법으로도 각 큐의 원소 합을 같게 만들 수 없는 경우, -1을 return 해주세요.

제한사항   
1 ≤ queue1의 길이 = queue2의 길이 ≤ 300,000   
1 ≤ queue1의 원소, queue2의 원소 ≤ 109   
주의: 언어에 따라 합 계산 과정 중 산술 오버플로우 발생 가능성이 있으므로 long type 고려가 필요합니다.   

입출력 예

|queue1|	queue2	|result|
|-|-|-|
|[3, 2, 7, 2]|	[4, 6, 5, 1]	|2|
|[1, 2, 1, 2]|	[1, 10, 1, 2]	|7|
|[1, 1]|	[1, 5]|	-1|


### 풀이

생각한 것과 달라서 시간이 오래 걸렸다.   
큐 두개의 pop과 insert를 반복하면서 서로 같은 값을 가져야 한다.    

따라서 완전 탐색을 해야 한다고 생각했었다.   
bfs를 구현하려고 했으나 구현이 쉽지 않았다.   
구현을 거의 다 했지만, 제한 시간 안에 통과하지 않을 것 같았다.   

따라서 다른 방법을 생각했다.   
최소한의 횟수로 해당 조건을 만족 하려면 두 큐의 합의 반 이상이 되는 부분 즉, 더 큰 부분이 pop을 하여 더 적을 큐로 insert하는 방법이면 해당 조건을    
만족할 수 있다.   

그렇다면 이제 예외가 되는 상황을 생각해보자.    
예외가 되는 상황은 두 큐의 합이 같아질 수 없을때이다.   
즉, 애초에 두 큐의 합이 홀수 이면 같아질 수 없다.   
또한 큐의 모든 원소가 교환이 되었을때 이다.   
이때는 모든 원소를 다 탐색한 경우이기 때문에 예외가 되는 상황으로 판별한다.   

추가로 생각한 예외상황은 다음과 같다.   
두 큐의 합이 30이라고 하자.   
이때 한쪽 큐의 원소가 30의 반인 15보다 큰 값이 있다고 하면 이때도 마찬가지로   
두 큐의 합을 같게 만들 수 가 없다고 생각했다.   

 ```java
 if (sum % 2 != 0 || Collections.max(queue1List) > (sum / 2) 
            || Collections.max(queue2List) > (sum / 2)) {
            return -1;
        }
```
따라서 이와 같은 조건을 세웠었는데 통과가 되지 않았다.  
여러 이유를 찾으려고 노력했지만, 그에대한 반례를 찾지 못했다.    
물론 이 경우도 위에서 기술한 조건에 포함되기 때문에 언젠가는 -1을 return하기때문에    
해당 부분은 제외하는 것에는 크게 문제가 없기때문에 이를 제거하고 풀이를 하였다.


