### 문제

수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.    

1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...   
2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...   
3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...   

1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.   


### 풀이

mod연산을 활용해서 풀이하였다.   
mod연산을 활용하면 반복된 인덱스를 쉽게 활용할 수 있다.   
각 정답에 대한 배열을 만들었다.   
1번의 정답배열 firstPeople을 {1, 2, 3, 4, 5}라고 하자.   
answer의 길이를 n 이라고 하고 인덱스 i = 0부터 차례로 순환한다.   
i를 firstPeople을의 길이만큼 mod연산을 해주면 인덱스가 0,1,2,3,4가 반복이 된다.   
즉, 계속해서 배열의 길이 이하만큼 순환이 가능하다.   
이를 이용해서 정답 갯수를 구할 수 있다.   

마지막으로 max정답자를 구하는 것을 고민을 했다.   
인덱스를 담은 list를 이용해서 각 경우를 나누어 list에 정답을 담았다.   
쉽게 Max.math를 이용해서 구하는 방법이 있었는데 왜 생각을 몬했지... ㅜ 

```java
int maxScore = Math.max(score[0], Math.max(score[1], score[2]));
        ArrayList<Integer> list = new ArrayList<>();
        if(maxScore == score[0]) {list.add(1);}
        if(maxScore == score[1]) {list.add(2);}
        if(maxScore == score[2]) {list.add(3);}
```
