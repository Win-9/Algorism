### 문제
경화는 과수원에서 귤을 수확했습니다.    
경화는 수확한 귤 중 'k'개를 골라 상자 하나에 담아 판매하려고 합니다.    
그런데 수확한 귤의 크기가 일정하지 않아 보기에 좋지 않다고 생각한 경화는 귤을 크기별로 분류했을 때 서로 다른 종류의 수를 최소화하고 싶습니다.  

예를 들어, 경화가 수확한 귤 8개의 크기가 [1, 3, 2, 5, 4, 5, 2, 3] 이라고 합시다.   
경화가 귤 6개를 판매하고 싶다면, 크기가 1, 4인 귤을 제외한 여섯 개의 귤을 상자에 담으면,    
귤의 크기의 종류가 2, 3, 5로 총 3가지가 되며 이때가 서로 다른 종류가 최소일 때입니다.  

경화가 한 상자에 담으려는 귤의 개수 k와 귤의 크기를 담은 배열 tangerine이 매개변수로 주어집니다.    
경화가 귤 k개를 고를 때 크기가 서로 다른 종류의 수의 최솟값을 return 하도록 solution 함수를 작성해주세요.

제한사항   
1 ≤ k ≤ tangerine의 길이 ≤ 100,000   
1 ≤ tangerine의 원소 ≤ 10,000,000   

입출력 예   
|k	|tangerine|	result|
|-|-|-|
|6|	[1, 3, 2, 5, 4, 5, 2, 3]	|3|
|4|	[1, 3, 2, 5, 4, 5, 2, 3]	|2|
|2|	[1, 1, 1, 1, 2, 2, 2, 3]	|1|



### 풀이

귤의 종류의 갯수가 최소가 되게 해야 한다.   
그렇다면 귤의 종류에 따라서 갯수를 저장 할 수 있는 자료 구조가 필요하다.   
이를 map이라고 생각 하였다.   
종류와 갯수를 map으로 저장 한 뒤, 귤을 k개 만큼 담아야 한다.   

종류를 최소화 하면서 담을 수 있는 방법은 무엇이 있을까?   
바로 갯수가 많은 수 부터 담는 것이다.   
따라서 map으로 담은 정보를 갯수가 많은 순으로 정렬하여 그 갯수를 많은 수 부터 차근차근 감소 시켜 나가면서 귤을 고르면 된다.  

map을 정렬할 수있는 방법은 TreeMap이 있지만, 우리는 value가 많은 순으로 정렬을 하려고 한다.   
따라서 key를 따로 담는 list를 만들고, 이를 value를 기준으로 더 많은 순서대로 정렬시키도록 한다.

```java
List<Integer> list = new ArrayList<>(map.keySet());

		Collections.sort(list, new Comparator<Integer>() {
			@Override
			public int compare(Integer o1, Integer o2) {
				return map.get(o2).compareTo(map.get(o1));
			}
		});
```

이후 내림차순대로 정렬된 list를 이용하여 map에서 한개씩 갯수를 추출하여 추출할때마다 answer를 더해준다.
