### 문제

일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다.   

임의의 인접한 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다.   
터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다.   
여기서 조건이 있습니다. 인접한 두 풍선 중에서 번호가 더 작은 풍선을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면,    

그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.

당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이 불가능할 수도 있습니다.   

일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요.   


### 풀이

처음에는 백트래킹을 생각하였다.   
처음부터 터뜨릴 수 있는 모든 경우의 수를 탐색하고, 그중
가장 최후가 가능한 값을 출력하려고 하였다.   

그러나 구현방도가 매우 복잡하였다.   
따라서 다른 방법을 사용하려고 하였다.   

중간의 어느 값을 지정해보고 생각해보자.   
결국 양쪽 모두 터뜨려질 것이고 지정된 수 보다 작은 값이 양쪽에 모두 위치해 있으면   
터뜨리는 것이 불가능해진다.   
따라서 해당 값은 그 이전에 터뜨려야 하므로 남기는 것이 불가능해진다.   

위의 방도로 구현의 했고, 먼저 이중 루프를 통하여 구현을 했었다.   
그러나 시간초과 오류가 발생했었고, O(n)이 가능하도록 구현을 해야 했다.   

각각 어느 특정 인덱스에서 Left와 right의 최솟값을 나타낼 수 있는 배열 두개를 만들고    
해당 배열의 위치에서 left, right배열의 인덱스와 비교하여 O(n)이 가능하도록 하였다.
