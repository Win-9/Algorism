### 문제
일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다.   

이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다.

1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.   
2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.   
3. 그렇지 않으면 J를 인쇄합니다.   
예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다.   

내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다.   

현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때,   
내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요.   

제한사항    
현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다.   
인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다.   
location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다.   

입출력 예   
|priorities	|location|	return|
|-|-|-|
|[2, 1, 3, 2]	|2	|1|
|[1, 1, 9, 1, 1, 1]	|0	|5|



### 풀이

큐를 이용한 풀이를 해야 한다.    
처음에는 굳이 모든 것을 구현하지 않고, 배열만 봤을 때 바로 그 정답을 구하는 방법을 알아내려고 했었다.   
Max값을 보았을때 그 전후의 인덱스를 비교하여 정답을 찾아내는 방법이었는데, 모두 구현을 하고 나서보니 이 경우는 고려해야할 예외상황이 너무 많이 있었다.   
따라서 차라리 시나리오대로 구현을 하는 것이 정답이라고 생각해서 다시 풀이 하였다.   
주어진 대로 풀이하면 간단하다.   
해당 배열을 리스트에 넣고, 그 인덱스를 기억하고 있는 인덱스 변수를 지정하여 상황에 맞게 옮기면 된다.

```java
while(list.size() != 0) {
            if (index == 0 && list.get(0) == Collections.max(list)) {
                answer++;
                return answer;
            }
            
            if (list.get(0) == Collections.max(list)) {
                list.remove(0);
                answer++;
            } else {
                list.add(list.remove(0));
            }
            
            if (index == 0) {
                index= list.size() - 1;
            } else{
                index--;
            }
        }
```

index변수가 제일 앞에 있고, 이것이 가장 큰 값이면 해당 값을 출력하고 종료한다.   
해당 변수가 제일 앞에 있지 않다면, 제일 앞에 있는 값이 Max임의 여부에 따라서 뽑아낼지 또는 맨 뒤로 다시 넣을지 결정한다.   
이때 이에 따라서 인덱스 변수는 인덱스 값이 줄어들지 또는 다시 맨 뒤로 가야할 지 결정하면 된다.  


빠르게 풀이 하려다가 오히려 시간을 더 많이 잡아먹었다.   
최대한 직관적으로 풀려는 습관을 길러야 겠다.
